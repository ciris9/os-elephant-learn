# 完善MBR
## 地址、section、vstart 浅尝辄止
### 什么是地址：

本质上，程序中各种数据结构的访问，就是通过“该数据结构的起始地址＋该数据结构所占内存的大小”来实现的。这就解释了为什么定义变量要给出变量类型，因为变量类型规定了变量所占内存大小，每种类型都有其对应的内存容量。

编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量

### 什么是section
就是段，帮助程序员划分为逻辑段的，但是但是对于nasm来说不关心。方便进行代码的编写。

### 什么是vstart
vstart 只是按照开发人员的意愿安排新的起始地址，不再以文件开头 0 为起始，其地址若超过文件大小则不会落在文件内，所以是虚拟的。

不管程序用的是不是虚拟地址，只要交给地址总线一个地址，地址总线就会去寻找该地址处的内容。
根据这个原则，只要保证该地址处的内容正是你所需要的即可。如果程序员用 vstart 指定了新的地址，干涉了编译器编址的方式，程序员要清楚地知道自己需要的东西是否会出现在物理内存中这个新的地址处。

## cpu实模式
### cpu工作原理
CPU 的工作原理。控制单元要取下一条待运行的指令，该指令的地址在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs：ip。于是读取 ip 寄存器后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到指令寄存器 IR 中。这时候轮到指令译码器上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程。操作码有了，操作数也齐了，操作控制器给运算单元下令，开工，于是运算单元便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址。接着控制单元又要取下一条指令了，流程回到了本段开头，CPU 便开始了日复一日的循环，由于 CPU 特别不容易坏，所以唯一它停下来的条件就是停电。

### 实模式下的寄存器
CPU 中的寄存器大致上分为两大类。
1. 一类是其内部使用的，对程序员不可见。“是否可见”不是说寄存器是否能看得见，是指程序员是否能使用。CPU 内部有其自己的运行机制，是按照某个预定框架进行的，为了 CPU 能够运行下去，必然会有一些寄存器来做数据的支撑，给 CPU 内部的数据提供存储空间。这一部分对外是不可见的，我们无法使用它们，比如全局描述符表寄存器 GDTR、中断描述符表寄存器 IDTR、局部描述符表寄存器 LDTR、任务寄存器 TR、控制寄存器 CR0～3、指令指针寄存器 IP、标志寄存器 flags、调试寄存器 DR0～7。
2. 另一类是对程序员可见的寄存器。我们进行汇编语言程序设计时，能够直接操作的就是这些寄存器，如段寄存器、通用寄存器。

### 实模式下的内存寻址方式
在实模式在，cpu访问数据按照段基址+段内偏移地址的方式进行访问。

寻址方式，从大方向来看可以分为三大类：
（1）寄存器寻址；
（2）立即数寻址；
（3）内存寻址。
在第三种内存寻址中又分为：
（1）直接寻址；
（2）基址寻址； bx
（3）变址寻址； di si 
（4）基址变址寻址。bx+di/si

ret call 
retf call far
jmp near
jmp far
还有一堆近转移，远转移之类的，这些就不多说了，属于是汇编语言基础。

### 标志寄存器
有无条件转移，当然也有有条件转移  
这些条件就放在了标志寄存器 flags 中。在名字上看，flag 加了 s，说明是 flag 的复数形式，是 flag 的集合，在此寄存器中有很多标志位。  
实模式下标志寄存器是 16 位的 flags，在 32 位保护模式下，扩展（extend）了标志寄存器，成为 32位的 eflags。  
值得一提的是，对于C语言这种高级语言而言，判断条件是存储在内存内的。  

标志位仅做了解即可。

**以下标志位仅在 8088 以上 CPU 中有效。**  
第 0 位的是 `CF` 位，即 `Carry Flag`，意为进位。运算中，数值的最高位有可能是进位，也有可能是借位，所以 carry 表示这两种状态。不管最高位是进位，还是借位，CF 位都会置 1，否则为 0。它可用于检测无符号数加减法是否有溢出，因为 CF 为 1 时，也就是最高位有进位或借位，肯定是溢出。再说点没用的，第 1、3、5、15 位没有专门的标志位，空着占位用。  
第 2 位为 `PF` 位，即 `Parity Flag`，意为奇偶位。用于标记结果低 8 位中 1 的个数，如果为偶数，PF 位为 1，否则为 0。注意啦，是最低的那 8 位，不管操作数是 16 位，还是 32 位。奇偶校验经常用于数据传输开始时和结束后的对比，判断传输过程中是否出现错误。  
第 4 位为 `AF` 位，即 `Auxiliary carry Flag`，意为辅助进位标志，用来记录运算结果低 4 位的进、借位情况，即若低半字节有进、借位，AF 为 1，否则为 0。  
第 6 位为 `ZF` 位，即 `Zero Flag`，意为零标志位。若计算结果为 0，此标志为 1，否则为 0。  
第 7 位为 `SF` 位，即 `Sign Flag`，意为符号标志位。若运算结果为负，则 SF 位为 1，否则为 0。  
第 8 位为 `TF` 位，即 `Trap Flag`，意为陷阱标志位。此位若为 1，用于让 CPU 进入单步运行方式，若为0，则为连续工作的方式。平时我们用的 debug 程序，在单步调试时，原理上就是让 TF 位为 1。可见，软件上的很多功能，必须有硬件的原生支持才能得以实现。  
第 9 位为 `IF` 位，即 `Interrupt Flag`，意为中断标志位。若 IF 位为 1，表示中断开启，CPU 可以响应外部可屏蔽中断。若为 0，表示中断关闭，CPU 不再响应来自 CPU 外部的可屏蔽中断，但 CPU 内部的异常还是要响应的，因为它关不住。  
第 10 位为 `DF` 位，即 `Direction Flag`，意为方向标志位。此标志位用于字符串操作指令中，当 DF 为1 时，指令中的操作数地址会自动减少一个单位，当 DF 为 0 时，指令中的操作数地址会自动增加一个单位，意即给地址的变化提供个方向。其中提到的这个单位的大小，取决于用什么指令。  
第 11 位为 `OF` 位，即 `Overflow Flag`，意为溢出标志位。用来标识计算的结果是否超过了数据类型可表示的范围，若超出了范围，就像水从锅里溢出去了一样。若 OF 为 1，表示有溢出，为 0 则未发生溢出。专门用于检测有符号数运算结果是否有溢出现象。以下标志位仅在 80286 以上 CPU 中有效。相对于 8088，它支持特权级和多任务。  
第 12～13 位为 `IOPL`，即 `Input Output Privilege Level`，这用在有特权级概念的 CPU 中。有 4 个任务特权级，即特权级 0、特权级 1、特权级 2 和特权级 3。故 IOPL 要占用 2 位来表示这 4 种特权级。如果您对此感到迷茫，不用担心，这些将来咱们在保护模式下也得实践。  
第 14 位为 `NT`，即 `Nest Task`，意为任务嵌套标志位。8088 支持多任务，一个任务就是一个进程。当一个任务中又嵌套调用了另一个任务（进程）时，此 NT 位为 1，否则为 0。  


**以下标志位仅用于 80386 以上的 CPU。**  
第 16 位为 `RF` 位，即 `Resume Flag`，意即恢复标志位。该标志位用于程序调试，指示是否接受调试故障，它需要与调试寄存器一起使用。当 RF 为 1 时忽略调试故障，为 0 时接受。  
第 17 位为 `VM` 位，即 `Virtual 8086 Model`，意为虚拟 8086 模式。这是实模式向保护模式过渡时的产物，现在已经没有了。CPU 有了保护模式后，功能更加强大了，但为了兼容实模式下的用户程序，允许将此位置为 1，这样便可以在保护模式下运行实模式下的程序了。实模式下的程序不支持多任务，而且程序中的地址就是真实的物理地址。所以在保护模式下每运行一个实模式下的程序，就要为其虚拟一个实模式环境，故称为虚拟模式。以下标志位仅用于 80486 以上的 CPU。  
第 18 位为 `AC` 位，即 `Alignment Check`，意为对齐检查。什么是对齐呢？是指程序中的数据或指令其内存地址是否是偶数，是否是 16、32 的整数倍，没有余数，这样硬件每次对地址以自增地方式（每次自加 2、16、32 等）访问内存时，自增后的地址正好对齐数据所在的起始地址上，这就是对齐的原理。对齐并不是软件逻辑中的要求，而是硬件上的偏好，如果待访问的内存地址是 16 或 32 的整数倍，硬件上好处理，所以运行较快。若 AC 位为 1 时，则进行地址对齐检查，为 0 时不检查。以下标志位只对 80586（奔腾）以上 CPU 有效。  
第 19 位为 `VIF` 位，即 `Virtual Interrupt Flag`，意为虚拟中断标志位，虚拟模式下的中断标志。  
第 20 位为 `VIP` 位，即 `Virtual Interrupt Pending`，意为虚拟中断挂起标志位。在多任务情况下，为操作系统提供的虚拟中断挂起信息，需要与 VIF 位配合。  
第 21 位为 `ID` 位，即 `Identification`，意思为识别标志位。系统经常要判断 CPU 型号，若 ID 为 1，表示当前 CPU 支持 CPU id 指令，这样便能获取 CPU 的型号、厂商等信息。若 ID 为 0，则表示当前 CPU 不  

### 实模式小结
实模式（Real Mode）是x86架构的CPU在启动时的一种工作模式，它允许操作系统直接访问所有的物理内存和硬件资源。在这种模式下，CPU的操作受到一些限制，例如：
 * 地址空间限制在1MB，即从0x00000到0xFFFFF的地址范围内。
 * 内存访问是分段的，使用16位的段基址和16位的偏移量来计算物理地址。
 * 指令集有限，不支持某些高级指令。
实模式通常用于操作系统的引导过程，因为在这个阶段操作系统还没有准备好切换到保护模式（Protected Mode），后者提供了更大的地址空间和更高级的内存管理功能。一旦操作系统加载并初始化了必要的组件，它就会切换到保护模式，以利用其提供的高级功能。

实模式被保护模式淘汰的原因，最主要是**安全隐患**。  
在实模式下，用户程序和操作系统可以说是同一特权的程序，因为实模式下没有特权级，它处处和操作系统平起平坐，所以可以执行一些具有破坏性的指令。  
程序可以随意修改自己的段基址，这样便在 1MB 的内存空间内不受阻拦，可以随意访问任意物理内存，包括访问操作系统所在的内存数据。这就给程序员开放了无限的自由，程序员访问内存可以说是指哪打哪。  
由于完全没有保护性可言，用户程序甚至可以覆盖操作系统在内存中的映像，整个计算机世界的和平全靠程序员的心情

## 操作显存
### cpu如何与外设通信 -- io接口
对于外设而言存在多种不同的形式，如何协调这些设备是一个值得考虑的问题。  
任何不兼容的问题，都可以通过增加一“层”来解决。在 CPU 和外设之间的这一层就是 IO 接口。IO接口形式不限，它可以是个电路板，也可以是块芯片，甚至可以是个插槽，它的作用就是在 CPU 和外设之间相互做协调转换，如 CPU 和外设速度不匹配，它就是变速箱，CPU 和外设信号不通用，它就是翻译机。

整点具体的，机箱里的声卡就是驱动音响设备的 IO 接口，本章介绍的显卡也同样是一种 IO 接口，它是用来驱动显示器的。也许您打开机箱后也未发现我说的声卡和显卡，那是不是就没有它们呢?当然不会，要是听不到声音看不到图像，人们买电脑干吗？用来学习的？其实它们被集成在主板芯片组中了，您用的就是集成声卡和集成显卡。这下清楚多了吧，下面咱们还是继续说点抽象的。

IO 接口是连接 CPU 与外部设备的逻辑控制部件，既然称为逻辑，就说明可分为硬件和软件两部分。硬件部分所做的都是一些实质具体的工作，其功能是协调 CPU 和外设之间的种种不匹配，如双方由于速度不匹配，那 IO 接口就实现数据缓冲以减少等待时间，数据格式不匹配，IO 接口就在这两种格式间互相转换。IO 接口内部实际上也是由软件来控制运作的，这就是所谓的“逻辑”部分，所以软件是指用来控制接口电路工作的驱动程序以及完成内部数据传输所需要的程序。

**其实说简单点，io接口就是作为解耦设备和cpu的中间层。**



CPU 太忙了，它的时间特别宝贵，为了简化 CPU 访问外部设备的工作，能够轻松地同任何硬件通信，大家就约定好 IO 接口的功能。
1. 设置数据缓冲，解决 CPU 与外设的速度不匹配CPU 和外设速度上的差异可以通过设置缓冲区来解决，也就是说，数据先存储在缓冲区里，等需要的时候（无论缓冲区是否满了）就传送出去。
2. 设置信号电平转换电路CPU 和外设的信号电平不同，如 CPU 所用的信号是 TTL 电平，而外设大多数是机电设备，故不能使用 TTL 电平驱动，可以在接口电路中设置电平转换电路来解决。
3. 设置数据格式转换外设是多种多样的，输出的信息可能是数字信号、模拟信号等，而 CPU 只能处理数字信号。数字信号需要经过数/模转换（D/A）成模拟量才能被送到外设以驱动硬件，模拟量也同样需要经过模/数（A/D）转换成数字量才能被 CPU 处理。所以接口电路中需要包括 A/D 转换器和 D/A 转换器。另外，即使双方使用的都是数字信号，这也牵涉到格式和字长的问题，如 CPU 使用的是 8 位、16 位或 32 位并行数据，而外设使用并行或串行数据都有可能，所以 IO 接口中必须能够识别格式并且转换成对方需要的形式才行。
4. 设置时序控制电路来同步 CPU 和外部设备硬件的工作也按照某种时序，它们都有自己的时序系统，就像 CPU 工作在自己的晶振时序上一样。双方时序不同，接口电路就要协调这两种不同的时间计法。例如，CPU 发控制信号、定时信号给 IO 接口电路，IO 接口用它们来控制和管理硬件。随后硬件有了反馈后，其应答信号也需要通过接口返回给 CPU，这样 CPU 先“问”，硬件后“回答”，就实现了一次握手，之后便可以实现 IO 的同步操作。
5. 提供地址译码CPU 同多个硬件打交道，每个硬件要反馈的信息很多，所以一个 IO 接口必须包含多个端口，即 IO接口上的寄存器，来存储这些信息内容。但同一时刻，只能有一个端口和 CPU 数据交换，这就需要 IO 接口提供地址译码电路，使 CPU 可以选中某个端口，使其可以访问数据总线。